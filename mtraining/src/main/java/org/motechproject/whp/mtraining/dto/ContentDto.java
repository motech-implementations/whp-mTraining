package org.motechproject.whp.mtraining.dto;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.Predicate;
import org.joda.time.DateTime;
import org.motechproject.whp.mtraining.util.ISODateTimeUtil;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

/**
 * Base class to be inherited by all contract objects of the course structure.
 * It defines the necessary fields that each object in a course structure should contain.
 * *  + contentId   : UUID that for a content (different from the _id generated by couch)
 *   + version     : content version (a content can have multiple versions, different versions of the content will have same contentId)
 *   + externalContentId  : Id that points to an external file or resource that is associated with the content.For eg. an audio file that is played to the enrollee when the content is started
 *   + createdBy    : Author of the content
 *   + createdOn    : Date on which content was created
 *   + isActive     : Whether the content is active or not.As of now deletion is soft delete meaning the content is inactivated.
 */

public abstract class ContentDto {
    private UUID contentId;
    private Integer version;
    private boolean isActive;
    private String externalContentId;
    private String createdBy;
    private DateTime createdOn;

    protected ContentDto() {
    }

    protected ContentDto(boolean isActive, String externalContentId, String createdBy) {
        this.isActive = isActive;
        this.createdBy = createdBy;
        this.externalContentId = externalContentId;
        this.createdOn = ISODateTimeUtil.nowInTimeZoneUTC();
    }

    protected ContentDto(UUID contentId, Integer version, boolean isActive, String externalContentId, String createdBy) {
        this(isActive, externalContentId, createdBy);
        this.contentId = contentId;
        this.version = version;
        this.createdBy = createdBy;
    }

    public UUID getContentId() {
        return contentId;
    }

    public Integer getVersion() {
        return version;
    }

    public void setContentId(UUID contentId) {
        this.contentId = contentId;
    }

    public ContentIdentifierDto toContentIdentifierDto() {
        return new ContentIdentifierDto(contentId, version);
    }

    public boolean isActive() {
        return isActive;
    }

    public String getCreatedBy() {
        return createdBy;
    }

    public DateTime getCreatedOn() {
        return createdOn;
    }

    public String getExternalContentId() {
        return externalContentId;
    }

    public boolean hasContentId(UUID contentId) {
        return this.contentId.equals(contentId);
    }

    protected static <T extends ContentDto> T findFirstActive(List<T> collection) {
        Object match = CollectionUtils.find(collection, new Predicate() {
            @Override
            public boolean evaluate(Object object) {
                ContentDto contentDto = (ContentDto) object;
                return contentDto.isActive();
            }
        });
        return (T) match;
    }

    protected static <T extends ContentDto> T findLastActive(List<T> collection) {
        List<T> copiedList = new ArrayList<>(collection);
        Collections.reverse(copiedList);
        Object match = CollectionUtils.find(copiedList, new Predicate() {
            @Override
            public boolean evaluate(Object object) {
                ContentDto contentDto = (ContentDto) object;
                return contentDto.isActive();
            }
        });
        return (T) match;
    }


    protected static <T extends ContentDto> T findWithContentId(final UUID contentId, List<T> contents) {
        Object match = CollectionUtils.find(contents, new Predicate() {
            @Override
            public boolean evaluate(Object object) {
                ContentDto contentDto = (ContentDto) object;
                return contentDto.hasContentId(contentId);
            }
        });
        return (T) match;
    }

    protected <T extends ContentDto> int findPosition(UUID otherContentId, List<T> contents) {
        for (int counter = 0; counter < contents.size(); counter++) {
            T content = contents.get(counter);
            if (content.getContentId().equals(otherContentId)) {
                return counter;
            }
        }
        return -1;
    }

}
